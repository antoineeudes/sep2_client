\chapter{Implementation}\label{ch:implementation}
Given the context and background of the IEEE 2030.5 protocol, and the high-level design decisions we've been required to make, we can discuss the technical design decisions present in our final implementation.
\section{Common Library}

\subsection{Resource Data Types}
The largest aspect of this common library is the internal representation of resources, the data communicated between clients \& servers. These resources are described precisely in an XSD.
Resources range from data that may be used by the electric utility, such as the current load of the device, to resource metadata, such as the rate at which a client should poll a server for a given resource, or what URI endpoint can be used to access a given resource, in the case of a Link resource.
In both specification and schema, these data structures are separated into packages for each of the function sets.

Whilst the 2030.5 specification makes no mention of the object oriented programming paradigm, OOP inheritance underpins the design of all resources, including both multi-level and hierarchial inheritance.
As such, for the purpose of code reuse, many base types appear in the 'common' package; data structures extended by many others.

\subsubsection{Representing Resources in Rust}
Rust, despite being influenced by OOP, does not posses the notion of a class, like in languages like C++ or Java. As such, Rust does not define shared behaviour of types through inheritance from a common parent type. 
Rather shared behaviour is defined through traits, where shared behaviour refers solely to the methods that we can call on that type, the traits a type implements.

In this sense, Rust polymorphism does not concern itself with what a type is or what that type stores, it concerns itself only with the traits it possesses.

Traits themselves do support inheritance. One can have traits that require other traits to be implemented for a given type. However, this does not change the fact that traits only represent behaviour. 
There is no way to have a data structure inherit the internal members of another.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEResource {
                fn href(&self) -> Option<&str>;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 "Resource" data type}
    \end{center}
\end{figure}



\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEList: SEResource {
                fn all(&self) -> Uint32;
                fn results(&self) -> Uint32;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

In Figure 5.2, we have a Rust trait that describes the behaviour of the List base type. All lists are resources, and thus we have a trait restriction that all types implementing List must first implement the Resource trait.

The prefix \texttt{SE} for 'Smart Energy' simply differentiates the trait from the concrete type with the same name.

This is the extent of native inheritance in rust. We can specify the exact behaviour of types that belong to a trait in detail, but we cannot influence how that behaviour is achieved.

\subsubsection{Emulating inheritance in Rust}

As a result, we're forced to emulate the inheritance of data structure members in Rust, of which there are two approaches:

\begin{itemize}
    \item Composite an instance of the base type into type definitions 
    \item Repeat all inherited members in type definitions
\end{itemize}

Regardless of the approach, we still do not have have polymorphism using the base-types of resources.
To allow for polymorphism a trait must be defined for each base-type, and then those trait functions need be implemented for every type that extends that base type. 
This is unavoidable duplicate code, although Rust provides mechanisms for which it can be generated at compile-time.

\subsubsection{Inheritance via Composition}

If we had implemented the first of the two approaches, we could have made use of an existing Rust library to reduce the amount of boilerplate required to implement polymorphism.
This library operates on the basis that inheritance can be replicated via composition. If a data type were to contain a member that implements a given trait, there is no reason for that outer struct to not be able to implement that trait by simply calling upon the underlying member.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[inheritable]
            pub trait Resource {
                fn get_href(&self) -> Option<&str>;
            }

            pub struct ResourceObj {
                href: Option<String>
            }

            impl Resource for ResourceObj {
                fn href(&self) -> Option<&str> {
                    self.href.as_str()
                }
            }
        \end{lstlisting}
        \label{fig:resinher}
        \caption{Rust code required to represent the IEEE 2030.5 "Resource" data type using 'inheritance-rs'}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Inheritance)]
            pub struct List {
                #[inherits(Resource)]
                res: ResourceObj,
                all: UInt32,
                results: UInt32,
            }
        \end{lstlisting}
        \label{fig:listinher}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} using 'inheritance-rs'}
    \end{center}
\end{figure}


Figures 6.3 and 6.4 show how this library, 'inheritance-rs' \cite[]{inheritancers} is used to reduce the boilerplate necessary to inherit data members. 
In Figure 6.3, we mark the Resource trait as 'inheritable' and then implement that trait on a type that holds the necessary members, our bare minimum 'base' type. 
In Figure 6.4, we compose an instance of that base type into a type that would normally inherit from it. Then, we tell the library to generate the code, at compile time, that would allow List to implement the Resource trait.
This generated code simply calls the underlying ResourceObj member when the href function would be called on a list.

The major flaw in this approach is that for every single type that is used as a base type, a trait, and a base implementation of that trait needs to be written.
Given that there are just under 700 data types in the IEEE 2030.5 schema, we had to consider alternatives.


\subsubsection{XSD to Rust types}

If we were to implement the second approach, an existing Rust library can be used to automate the process of defining data types altogether.
This of course draws on the fact that the IEEE 2030.5 XSD is entirely self-contained, and follows XSD guidelines by W3C. As such, generating rust data types from it is a reasonable approach.
One such way to automate this process would be to design and implement our own XSD parser, however, we are not the first to require this tool. 

On the Rust public crates registry there are several XSD parsers, many of which existing to solve very similar problems; implementing standardised communication protocols in Rust.
However, for that reason, many of these implementations are developed until they meet the creators needs, at which point the tool is no longer maintained.

Of the most complete parsers, one particular implementation stands out. This particular implementation supports hierarchial inheritance and makes reasonable assumptions on the internal representations of primitive data types.
\texttt{xsd-parser-rs} by \texttt{Lumeo}, was created for use in their \texttt{Open Network Video Interface Forum Client}, software with requirements not dissimilar from that of IEEE 2030.5. \cite[]{xsdparserrs}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Default, PartialEq, Debug, YaSerialize, YaDeserialize)]
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            pub struct List {
                // The number specifying "all" of the items in the list. 
                // Required on a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "all")]
                pub all: Uint32,
            
                // Indicates the number of items in this page of results.
                #[yaserde(attribute, rename = "results")]
                pub results: Uint32,
            
                // A reference to the resource address (URI). 
                // Required in a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "href")]
                pub href: Option<String>,
            }
        \end{lstlisting}
        \label{fig:listauto}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} as generated by \texttt{xsd-parser-rs}}
    \end{center}
\end{figure}

Figure 6.5 is what \texttt{xsd-parser-rs} currently produces for the List resource. In this figure, it's parsed that the List type inherits from the Resource type, and included the href data member accordingly. It's also included the documentation as found in the schema.

Compared to true OOP inheritance, this has types include their parent type data members in their own type definitions.
Despite this, the type definitions are far more readable, and align more closely with the output of the client, in that inheritance is flattened out.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <List xmlns="urn:ieee:std:2030.5:ns" all="0" results=0" 
            href="/sample/list/uri" />
        \end{lstlisting}
        \label{fig:listxml}
        \caption{An XML representation of an IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

Figure 6.6 shows the List data type were it a concrete data type serialized into XML.

Further advocating for the use of an XSD parser is the fact that the 2030.5 XSD is updated more often than revisions of the specification itself, even if those updates are relatively infrequent.
Using \texttt{xsd-parser-rs} will allow us to better maintain the client, by way of simply running updated schemas through the parser, should it change drastically as a result of a major revision (although this is unlikely).

Of course, \texttt{xsd-parser-rs} does not perfectly fit our needs. However, it is released under the MIT license, giving us the freedom to fork the library, and modify it to suit our needs. As part of our implementation we've:

\begin{itemize}
    \item Instructed it to use the Rust Option type where \texttt{minOccurs=0} and \texttt{maxOccurs=1}.
    \item Instructed it to provide us with all types in a type's inheritance tree.
    \item Manually implemented Rust enums for all types that are integer enumerations.
    \item Manually implemented Rust \texttt{bitflags} for all integer bitmap types.
    \item Modified the Derive output on all data types to automatically implement traits where useful.  
\end{itemize}

\subsubsection{Integer Bitmaps}
IEEE 2030.5, for the sake of efficiency, has many fields that encode many boolean values together in a single integer, a bitmap of booleans, or colloquially a 'bitflag'. Whilst we must still maintain how these integers are stored internally, we have the opportunity to provide them in a more ergonomic interface. Thus, we use the \texttt{bitflags} crate, a popular Rust crate that wraps integers and provides convenience functions for comparing them (intersections, unions), and constructing them using enum like syntax. \cite{bitflags}

\subsubsection{Resource Polymorphism}
As mentioned, we've used \texttt{xsd-parser-rs} to automate the process of resolving an inheritance tree in the XSD. This has enabled us to add polymorphism via Resource base types to our implementation.

We add Resource polymorphism to our common library as it can be implemented relatively easily, and assists both ourselves in writing more generic code (such as the Event scheduler), and users of our library, such as by allowing them to store all "Subscribable" resources in a single container.

Therefore, as part of the common library, we define a set of Rust traits that mirror common fields in resources. 

Since IEEE 2030.5 does not use multiple inheritance (inheriting from more than one base type), if we were to mirror base types to traits exactly, we would be implementing a confusing level of redundancy into our traits.
For example, \texttt{RespondableSubscribableIdentifiedObject} inherits from \texttt{RespondableSubscribableObject}, providing it with three new fields that allow it to be 'Identified'. Similarly, \texttt{RespondableIdentifiedObject} inherits from \texttt{RespondableObject}, also providing it with the Identified fields. In this example, Resources become 'identified' in two different ways. Rather than have two traits that provide the same behaviour, but with two different supertraits, we simplify and provide a single \texttt{SEIdentifiedObject} trait. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            /// Implemented by all types whose base type is [`IdentifiedObject`]
            trait SEIdentifiedObject: SEResource {
                fn mrid(&self) -> &MRIDType;
                fn description(&self) -> Option<&String32>;
                fn version(&self) -> Option<VersionType>;
            }
        \end{lstlisting}
        \label{fig:identtrait}
        \caption{Our implementation of the IdentifiedObject trait}
    \end{center}
\end{figure}

To implement these traits for all relevant types we use Rust's procedural macros - Rust code that runs at compile time producing more code to be compiled. A straight forward implementation gives us the ability to derive any of these traits on a type that possesses all the required fields.

Manually adding these Derive annotations to all our data types is unfeasible. Instead, we use our \texttt{xsd-parser-rs} fork to evaluate all the inheritance in the inheritance tree of a specific type, and use it to automate this process entirely. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                SERandomizableEvent,
                SEEvent,
                SERespondableSubscribableIdentifiedObject,
                SEIdentifiedObject,
                SESubscribableResource,
                SERespondableResource,
                SEResource,
            )]
            struct EndDeviceControl { ... }
        \end{lstlisting}
        \label{fig:edctraits}
        \caption{The output of \texttt{xsd-parser-rs} for \texttt{EndDeviceControl}}
    \end{center}
\end{figure}

The result is all IEEE 2030.5 resources include trait implementations defining behaviour shared between them. 



\subsection{Resource Serialisation \& Deserialisation}
IEEE 2030.5 resources can be sent as their XML representations over HTTP. This means our common library requires the ability to serialize and deserialize resources to and from the appropriate XML.
This means HTTP requests containing resources are sent with \texttt{Content-Type} set to \texttt{application/sep+xml}.

On the public Rust crates registry, there exists a popular XML serialisation and serialization library purpose built for use in embedded communication protocols called \texttt{YaSerde} \cite[]{YaSerde}.
Despite being developed by different teams, the syntax to use \texttt{YaSerde} on Rust data types is auto-generated by \texttt{xsd-parser-rs}, and as such, is to be used in our client implementation.

Referring again to Figure 6.5, we see \texttt{xsd-parser-rs} has qualified our struct with the appropriate namespace, such that YaSerde serializations will include it, and deserializations will expect it.
Furthermore, names of data members have been specified as attributes, rather than child elements in the resulting XML; determined by the parser as per the XSD.
Figure 6.6 is an example of what the List type looks like when serialized to XML.

\texttt{YaSerde} does not perfectly fit our needs. However, it is also released under the MIT license, giving us the freedom to fork it, and add our required functionality.
As part of our work we've modified \texttt{YaSerde} (\texttt{sepserde}) in order to:

\begin{itemize}
    \item Serialize Rust enums as their underlying integer representations.
    \item Allow for Rust trait objects (dynamic dispatch) to be created on the serialize and deserialize traits.
    \item Serialize and deserialize IEEE 2030.5 \texttt{HexBinary} primitives as hexadecimal with an even number of digits. 
    \item Allow \texttt{bitflags} generated bitmaps to be serialized and deserialized.
    \item Allow for generic resources to be serialized and deserialized (Notification)
\end{itemize}

\subsubsection{Notification}
The 'Notification' resource is a container for delivering resources to clients via the Subscription / Notification method. This means a Notification resource is generic, it contains some Resource as one of it's fields. To represent this as a type, we use Rust generics, where the generic type is bound by the 'SEResource' trait we've defined.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            struct Notification<T: SEResource> {
                resource: Option<T>,
                ...
            }
        \end{lstlisting}
        \label{fig:notifgeneric}
        \caption{Notification resource implemented using Rust generics}
    \end{center}
\end{figure}

This type representation uses Rust's monomorphization, and therefore has no runtime overhead in order to make the Resource type generic.

However, this poses some challenges for \texttt{YaSerde} which was not written with this sort of use case in mind. Even more so, the XML representation of a Notification resource is unique, in terms of how it expresses the type of the inner resource.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
        <Notification xmlns="urn:ieee:std:2030.5:ns" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <subscribedResource>/upt/0/mr/4/r</subscribedResource>
            <Resource xsi:type="Reading">
                <timePeriod>
                    <duration>0</duration>
                    <start>12987364</start>
                </timePeriod>
                <value>1001</value>
            </Resource>
            <status>0</status>
            <subscriptionURI>/edev/8/sub/5</subscriptionURI>
        </Notification>        
        \end{lstlisting}
        \label{fig:notifxml}
        \caption{Example Notification<Reading> resource from IEEE 2030.5}
    \end{center}
\end{figure}

Figure 6.10 shows a Notification resource that contains a Reading resource. Of interest is that the inner resource is always contained in an XML element with the name "Resource", and the type of the inner resource is instead given by the 'type' attribute, provided by the \texttt{XMLSchema-Instance} namespace. 

The implication of this is not only do we need to modify \texttt{sepserde} to handle generic resources, but we also need a way to instruct it to add this  \texttt{xsi:type} attribute accordingly.

When setting the \texttt{xsi:type} attribute, we note that we require the name of the resource as a String. This means for every Resource we also need to somehow bundle along with it a string literal of the name of the type. We do this by having the procedural macro responsible for generating the serialisation code also define a function that contains that string literal.

Throughout our implementation, we've also found additional use for this function, using it to provide the name of the resource as additional context when creating logs in generic functions.

In order to instruct \texttt{sepserde} to place this \texttt{xsi:type} attribute as required, we add a new procedural macro attribute to the library, \texttt{generic}.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                YaSerialize, YaDeserialize, SESubscriptionBase, SEResource,
            )]
            #[yaserde(
                namespace = "urn:ieee:std:2030.5:ns",
                namespace = "xsi: http://www.w3.org/2001/XMLSchema-instance"
            )]
            pub struct Notification<T: SEResource> {
                #[yaserde(rename = "Resource")]
                #[yaserde(generic)]
                pub resource: Option<T>,
                ...
            }    
        \end{lstlisting}
        \label{fig:notifimpl}
        \caption{Our Notification resource implementation}
    \end{center}
\end{figure}

Figure 6.11 this in use, we append the additional namespace as required, and include the \texttt{generic} annotation. The result is that an instance of a \texttt{Notification<T: SEResource>} serialises and deserialises successfully. 


\subsubsection{NotificationList}
Unlike the Notification resource, the NotificationList resource's purpose are more ambiguous. In IEEE 2030.5 a NotificationList resource is described as a "List of Notifications" and that it is a "List Resource that supports multiple types". This could be interpreted in a few ways:

\begin{itemize}
    \item Each Notification in a Notification List can contain a different inner resource
    \item All Notifications in a NotificationList must contain the same resource
    \item A NotificationList is a Notification of a List Resource, where that List resource is split up into multiple individual notifications.
\end{itemize}

The latter two interpretations would lead themselves to the most trivial implementation, a NotificationList need simply have a single generic type. The first interpretation would be, as a result of Rust's type-system, very much non-trivial, and would require each Notification to store a SEResource trait object (dynamic dispatch), as to force each Notification to have the same concrete type.
Fortunately, as mentioned in 5.2.1 we assume developers would want to use different routes for different notifications, making the first interpretation irrelevant.

However, that does not yet clarify which of the latter two are correct. In any case, this is merely the behaviour of the NotificationList after being deserialised, and not something we as library developers need to worry about. For that reason we implement NotificationList as simply a list of Notifications, all with the same inner resource.

\subsubsection{Exploring Dynamic Deserialisation}
Dynamic deserialisation was a feature we explored implementing in our \texttt{YaSerde} fork; the ability to determine how a given XML string should be deserialised at runtime, instead of having to know at compile-time, as it is now.

The protocol's WADL XML document outlines all the routes a IEEE 2030.5 server can provide, and what type of resource is expected on that route. Coupled with the assumption that library users implementing the Subscription / Notification will use different routes for different incoming resources, we can deduce that the type of all incoming XML resources can be determined at compile time, and thus the need to inspect Resources and determine how they should be deserialised isn't at all necessary. 

Regardless, as part of this thesis we explored how this might be accomplished in Rust, in order to determine if it would work to improve the ergonomics of our common library interface.

In order to have a Rust function that deserialise all valid resources, even if the type is not known, we require that the function returns a single concrete type. For this we could use trait objects, Rust dynamic dispatch, which has the function return a 'fat' pointer to the Resource's internal representation (usually on the heap) and a table containing function pointers for the corresponding trait, often called a 'vtable' or 'virtual method table'. 

Implementing this function with a trait object return type would require a significant time investment, redesigning the existing \texttt{YaSerde} code, having it return a \texttt{Box<T>}, instead of \texttt{T}.

An alternative to using trait objects would be to have a Rust tagged union (an enum) of all resource types, every resource would therefore have the same concrete type once wrapped in that enum.

Regardless of the approach, we would also need to implement some form of lookup mapping the names of resources to code that deserialize based off the type of the resource - this would likely need to be auto-generated.

If a trait object was used, the return type of the function doesn't provide users with anything immediately useful, in order to inspect the contents of the resource, they would need to downcast the trait object to a concrete type, which requires them to first know the concrete type at compile-time, bringing us back to the original problem.

The Rust enum approach improves this situation. When combined with Rust match statements library users can filter to a concrete Resource as needed. However, with 141 different resources it's likely this filtering would be very verbose. Given that client developers should know the type of all incoming resources at compile time, implementing this functionality ourselves would force library users to handle this filtering themselves, even if they don't necessarily require it.

For that reason, we won't be implementing any form of run-time deserialisation. If users require any of the approaches we've discussed, they have the ability to implement it themselves, or more reasonably, switch to a dynamically typed language where this model can be more easily supported, as we saw in the \texttt{envoy-client}.

\subsection{List Ordering}
IEEE 2030.5 defines list resources as simply a list of resources that can be retrieved in a single request. For each list resource, the specification defines how the list should be ordered, which values should be used as keys, and the precedence of those keys. \cite{IEEE2030.5}

Therefore, for all resources that are used in a list we've implemented the Rust \texttt{Ord} trait, which defines a total order (as opposed to a partial order), that will be used when using default sort methods on the list itself.

Unfortunately, this is not described in any standardised way, and was instead implemented manually.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            impl Ord for DERControl {
                fn cmp(&self, other: &Self) -> std::cmp::Ordering {
                    // Primary Key - primacy (ascending)
                    match self.interval.start.cmp(&other.interval.start) {
                        core::cmp::Ordering::Equal => {}
                        ord => return ord,
                    }
                    // Secondary Key - creationTime (descending)
                    match self.creation_time.cmp(&other.creation_time).reverse() {
                        core::cmp::Ordering::Equal => {}
                        ord => return ord,
                    }
                    // Tertiary Key - mRID (descending)
                    self.mrid.cmp(&other.mrid).reverse()
                }
            } 

            impl PartialOrd for DERControl {
                fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                    Some(self.cmp(other))
                }
            }
        \end{lstlisting}
        \label{fig:dercord}
        \caption{Our ordering implementation for the DERControl trait}
    \end{center}
\end{figure}

Figure 6.12 shows our implementation of this, where we first implement a total order, and then use that to implement the required partial order.

To provide an ergonomic way for working with lists, and ensure lists are always sorted, we use our procedural macros to provide a common interface for working with list resources. List resources contain a Rust \texttt{Vec} internally, which can be pushed to directly, but does not retain the sortedness.

Instead, we provide a \texttt{add} function on all lists that inserts and retains the intended order. This function also updates the 'all' field of the resource (the length of the list), to ensure it remains consistent with the actual contents of the list. Similarly, we provide a \texttt{remove} function. For all other, less common use cases, library users will be required to update the list invariants as necessary. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEList: SEResource {
                type Inner: Ord;
                fn all(&self) -> Uint32;
                fn all_mut(&mut self) -> &mut Uint32;
                fn results(&self) -> Uint32;
                fn results_mut(&mut self) -> &mut Uint32;
                fn list_as_slice(&self) -> &[Self::Inner];
                fn list_mut(&mut self) -> &mut Vec<Self::Inner>;
            
                /// Add an item to the contained list, maintaining invariants
                fn add(&mut self, item: Self::Inner) {
                    self.list_mut().push(item);
                    // 'very fast in cases where the slice is nearly sorted'
                    self.list_mut().sort();
                    *self.all_mut() = Uint32(self.all().get() + 1);
                }
                ///Remove an item from the contained list, maintaining invariants
                fn remove(&mut self, idx: usize) -> Self::Inner {
                    *self.all_mut() = Uint32(self.all().get() - 1);
                    self.list_mut().remove(idx)
                }
        \end{lstlisting}
        \label{fig:listtraitimpl}
        \caption{Our SEList trait, with default add and remove methods.}
    \end{center}
\end{figure}

\subsection{CSIP-AUS}
Implemented in \texttt{sep2\_common} are the IEEE 2030.5 extensions required by CSIP-AUS. These take the form of two additional resources, and additional fields on existing resources. When extensions are used, IEEE 2030.5 requires that the XML namespace for the extension be included with the Resource, and that extension specific fields be prefixed accordingly. For CSIP-AUS this is the \texttt{https://csipaus.org/ns} namespace, and the \texttt{csipaus} prefix. \cite{CSIPAus}

We make CSIP-AUS extensions available behind the \texttt{csip\_aus} crate feature (crate compile flag). When activated, the Rust compiler adds the namespace to existing IEEE 2030.5 resources, and adds the prefix to their respective fields. It also makes the new resources available for use, also with the correct namespace and prefix. Using existing functionality of \texttt{YaSerde}, adding these extensions is straight-forward.

As per the Energy Queensland SEP2 Client Handbook, and the CSIP-AUS publication by ARENA, these resources, and our support for the client aggregation model, are the extent to which we as library developers can assist users in developing CSIP-AUS compliant clients. \cite{sep2clienthandbook} \cite{CSIPAus}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            #[cfg_attr(
                feature = "csip_aus",
                yaserde(namespace = "csipaus: https://csipaus.org/ns")
            )]
            pub struct DERCapability {
                /// Bitmap indicating the CSIP-AUS controls implemented
                #[cfg(feature = "csip_aus")]
                #[yaserde(rename = "doeModesSupported")]
                #[yaserde(
                    prefix = "csipaus", 
                    namespace = "csipaus: https://csipaus.org/ns"
                )]
                pub doe_modes_supported: DOEControlType,
                ...
            }
        \end{lstlisting}
        \label{fig:csipausimpl}
        \caption{The DERCapability annotated with optional CSIP-AUS extensions.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <EndDevice xmlns="urn:ieee:std:2030.5:ns" 
                       xmlns:csipaus="https://csipaus.org/ns">
                <changedTime>0</changedTime>
                <csipaus:ConnectionPointLink  href="/edev/1/cp" />
                <sFDI>0</sFDI>
            </EndDevice>
        \end{lstlisting}
        \label{fig:enddeviceconnpointxml}
        \caption{Example XML representation of a EndDevice Resource with a CSIP-AUS ConnectionPointLink.}
    \end{center}
\end{figure}

Figure 6.15 shows the output of our common library when an EndDevice is constructed with a ConnectionPointLink resource, and when the \texttt{csip\_aus} compile flag is enabled.


\subsection{MRID Generation}
IEEE 2030.5 Servers and Clients are both capable of creating resources. Resources where multiple instances can exist contain a "Master Resource Identifier" or an "MRID", a 128 bit integer that is globally unique.
As such, library users will require a way of reliably creating cryptographically unique MRIDs. One requirement of the MRIDs is that they contain a IANA Private Enterprise Number (PEN) in the least significant 32 bits of the MRID.

For that reason, we provide users of our library with a function with the signature \texttt{fn mrid\_gen(pen\_id: u32) -> MRIDType} that produces a new MRID each time it's called.

IEEE 2030.5 provides the requirement that MRIDs are sufficiently cryptographically unique, where the risk of an MRID collision is minimised. The EPRI C implementation defines an algorithm for generating MRIDs that ensures, at the very minimum, that two MRIDs produced by a single instance of the program will never collide, by use of a global, mutable, atomic integer that increments each ID. Since EPRI was able to release their MRID generation algorithm as part of their library, we assume it's sufficient, and implement a very similar algorithm in Rust.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            static MRID_COUNT: AtomicU32 = AtomicU32::new(0);

            fn mrid_gen(pen_id: u32) -> MRIDType {
                let id: u128 = /* Generate Random u128 */
                let time: u128 = /* Get Unix Timestamp */
                let count: u128 = /* Fetch and increment MRID_COUNT */
                HexBinary128((time << 32) 
                            | (id << 32) | (count << 32) 
                            | pen_id as u128)
            }
        \end{lstlisting}
        \label{fig:mridgenalgo}
        \caption{Our implementation of an MRID generator, inspired by EPRI's.}
    \end{center}
\end{figure}


Going forward, it would be ideal to calculate the possibility of a global collision with this algorithm, as to verify that is is sufficiently cryptographically unique, however, this is out of scope of this thesis.

Regardless, we do of course provide unit tests for this functionality. We provide a test verifying that the PEN ID can be obtained from a given MRID, and that there are no collisions when generating several million MRIDs on a single instance of the program. This is to be expected, as we use include a global, mutable counter in the final value.

\subsection{Testing}
\texttt{sep2\_common} is developed alongside a suite of tests, ensuring all resources can be serialised and deserialised, and that their XML representations adhere to IEEE 2030.5.

\subsubsection{Testing SEPSerde}
As expected, by the nature of serialisation and deserialisation, we have no compile time guarantees either will succeed for a given data type.
Therefore, our first test suite for the common library is to test that all data types can be serialized \& deserialized successfully, and that it can be done without any data loss.

\begin{figure}[h]
    \begin{center}
        \begin{lstlisting}
            #[test]
            fn default_List() {
                let orig = List::default();
                let new: List = deserialize(&serialize(&orig).unwrap()).unwrap();
                assert_eq!(orig, new);
            }
        \end{lstlisting}
        \label{fig:yaserdetest}
        \vspace{-10pt}
        \caption{A Rust test verifying that the IEEE 2030.5 List resource can be serialized \& deserialized}
    \end{center}
\end{figure}

The logic for a test of this type can be succinctly expressed in Rust, as seen in Figure 5.7. 
This test takes advantage of the fact that all our resources are able to automatically implement the 'default' trait, and as such an instance of any resource can be instantiated with default values.
In Figure 5.7, we first perform this default instantiation, convert the resource to an XML string, and then convert the XML string back into our internal List representation. 
Finally, we check if the newly deserialized resource is equal to it's default.

For each resource, the only part of this test that differs is the name of the type. As such, we auto-generate it and include it in the common library.

\subsubsection{XML Correctness}
The remainder of the common library will be tested using manually written unit tests that test whether our XML representations of resources are correct with respect to IEEE 2030.5
These unit tests use the example XML resources provided as part of IEEE 2030.5, as they are more likely to be correct than resources we would write by hand.

\section{Client Library}
Despite the claim that we are developing an IEEE 2030.5 client, in reality, the goal of this thesis is to produce a client library, such that manufacturers of IEEE 2030.5 complaint devices will extend upon our client.
These device manufacturers would simply, in Rust or otherwise, call upon the documented interface of the client library to communicate with a IEEE 2030.5 server.

The exact details of this client library interface are yet to be determined, but what a developer should be able to achieve with that interface is fairly straight forward. They'll require:

\begin{itemize}
    \item A mechanism for discovering or connecting to a specific server.
    \item The ability to retrieve resources from a specific URI, and have it deserialized into a local data type.
    \item The ability to create or update a resource, and have it included as a PUT or POST request to a connected server.
    \item A mechanism to automate this process, using event-driven architecture, to handle timer events, such as for polling, or network events for resource subscription.
\end{itemize}

\subsection{Server \& Connection}

Connecting to a server is, otherwise, as expected. We use the cipher suite interface and the TCP interface, as built in the common library, to connect to the server using TCP/TLS.
This of course requires certificates signed by a common library cipher suite. This certificate exchange will determine the parameters by which the cipher suite will be used to encrypt traffic.

\subsection{Event-driven Architecture}
With the IEEE 2030.5 Client being an I/O bound application, we are to implement concurrency using an event-driven architecture, such that many operations can performed concurrently on a single threaded machine when waiting on I/O.

Although the client does not connect to multiple servers, we require event-based architecture to handle:
\begin{itemize}
    \item Input from the client device, such as the creating or updating of resources.
    \item Timed events, such as to poll for a resource update on a given schedule.
    \item Network events, such as an updated resource being pushed to the client via the subscription/notification mechanism, or receiving the response from a sent HTTP request.
\end{itemize}

An event-based architecture furthermore enables us to take advantage of multiple OS threads, and therefore multiple CPU cores, as to best accommodate the scale required by the client aggregator model.
As mentioned previously, Rust supports asynchronous programming, with runtime-agnostic support for await and async syntax, of which there are multiple Rust async runtime available.

The specifics of this asynchronous programming architecture are yet to be learned, and as such we can look to the EPRI client implementation, where they've chosen to use the Linux native \texttt{epoll} \texttt{syscall}.
Fortunately, \texttt{epoll} is the driver behind the two most popular async runtimes for Rust, \texttt{Tokio} and \texttt{std-async}. As such, we'll need to determine which is most suitable for our client.

\subsection{Function Sets}
As established, function sets are logical groupings of IEEE 2030.5 resources by their functionality, of which there are twenty-five.
A subset of these function sets are for general or 'Common' use, such as the time function set, for synchronizing a device clock, whilst others have a very specific scope, such as the Electric Vehicle function set. 

QualityLogic, a quality assurance company specialising in testing standardised software, has grouped these function sets further than the specification itself.

Figure 5.8 shows these groupings, and which of these function sets are required for California SIP.
These groupings provide us with a starting point for determining the priority of function sets, where by those required for California SIP will be implemented first.
An exception to this is the Demand Response and Load Control function set, which has been deemed relevant for DER in Australia by electric utilities in Queensland, and as such it's implementation will be prioritised. \cite[]{QueenslandDER}

Regardless, the groupings in Figure 5.8 further indicate the dependencies between function sets. For example the Device Capabilities function set describes the function sets available on a server, and is therefore used to discover the URI of resources for other function sets.

The conclusion to draw from this is that function sets on the left side of Figure 5.8 are very much depended upon by function sets on the right side, as they describe the core functionality on the client.
Our development will begin on the Security, Certificate Management, and Application Support function sets as part of the common library, where the Application Support function set refers to the use of prescribed technologies, such as TCP, HTTP/1.1 and XML.


\subsection{Testing}
As expected, our client library will be developed alongside a suite of tests. Unlike the common library, these tests will be comprised of both unit and system tests.
System tests will primarily be used to check for conformance to the IEEE 2030.5 specification, using the example system outputs in the specification.
The actual software framework to be used for conducting system tests is yet to be determined, but the requirements to use such a framework are relatively straightforward, obviously requiring both a test client binary, and a mock server.


\subsubsection{Test Client Binary}
In order to perform system tests we will need to wrap our client library and produce a binary that will connect to a server, simulating a potential use case.
This binary client will be a demonstration of all implemented functionality.
Furthermore, this client binary will act as documentation for device manufacturers using our library.
Likewise, EPRI produced a test client binary for demonstration purposes in their IEEE 2030.5 client implementation.

\subsubsection{Mock Server}

When it comes to writing system tests, our testing philosophy is hindered by a lack of open-source IEEE 2030.5 implementations, in-development or otherwise.
As such, we'll need to create our own mock IEEE 2030.5 server to test both the sending and receiving of resources from our client.
Neel Bhaskar, as part of UNSW CSE, developed a portion of a working IEEE 2030.5 Server in 2022, and with changes to support hardcoded resources and routes, will be used as the starting point for this mock server.
We will also need to make changes to this server in order for it to use our common library, where we will therefore gain a better idea of what functionality is common to both client \& server.

Specific client functionality, such as the subscription/notification method of resource retrieval, may require extensive work on this mock server. 
As a result, we won't rule out the possibility of writing code that could be reused in a future server implementation.









