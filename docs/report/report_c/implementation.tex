\chapter{Implementation}\label{ch:implementation}
Given the context and background of the IEEE 2030.5 protocol, and the high-level design decisions we've been required to make, we can discuss the technical design decisions present in our final implementation.

\section{Common Library}
The common library, \texttt{sep2\_common}, contains all functionality that we have determined to be common to both IEEE 2030.5 clients and servers.

\subsection{Resource Data Types}
The largest aspect of the common library is the internal representation of resources, the data communicated between clients \& servers. These resources are described precisely in an XSD.
Resources range from data that may be used by the electric utility, such as the current load of the device, to resource metadata, such as the rate at which a client should poll a server for a given resource, or what URI endpoint can be used to access a given resource, in the case of a Link resource.
In both specification and schema, these data structures are separated into packages for each of the function sets.

Whilst the 2030.5 specification makes no mention of the object oriented programming paradigm, OOP inheritance underpins the design of all resources, including both multi-level and hierarchial inheritance.
As such, for the purpose of code reuse, many base types appear in the 'common' package; data structures extended by many others.

\subsubsection{Representing Resources in Rust}
Rust, despite being influenced by OOP, does not posses the notion of a class, like in languages like C++ or Java. As such, Rust does not define shared behaviour of types through inheritance from a common parent type. 
Rather shared behaviour is defined through traits, where shared behaviour refers solely to the methods that we can call on that type, the traits a type implements.

In this sense, Rust polymorphism does not concern itself with what a type is or what that type stores, it concerns itself only with the traits it possesses.

Traits themselves do support inheritance. One can have traits that require other traits to be implemented for a given type. However, this does not change the fact that traits only represent behaviour. 
There is no way to have a data structure inherit the internal members of another.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEResource {
                fn href(&self) -> Option<&str>;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 "Resource" data type}
    \end{center}
\end{figure}



\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEList: SEResource {
                fn all(&self) -> Uint32;
                fn results(&self) -> Uint32;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

In Figure 5.2, we have a Rust trait that describes the behaviour of the List base type. All lists are resources, and thus we have a trait restriction that all types implementing SEList must first implement the SEResource trait.

The prefix \texttt{SE} for 'Smart Energy' simply differentiates the trait from the concrete type with the same name.

This is the extent of native inheritance in rust. We can specify the exact behaviour of types that belong to a trait in detail, but we cannot influence how that behaviour is achieved.

\subsubsection{Emulating inheritance in Rust}

As a result, we're forced to emulate the inheritance of data structure members in Rust, of which there are two approaches:

\begin{itemize}
    \item Composite an instance of the base type into type definitions 
    \item Repeat all inherited members in type definitions
\end{itemize}

Regardless of the approach, we still do not have have polymorphism using the base-types of resources.
To allow for polymorphism a trait must be defined for each base-type, and then those trait functions need be implemented for every type that extends that base type. 
This is unavoidable duplicate code, although Rust provides mechanisms for which it can be generated at compile-time.

\subsubsection{Inheritance via Composition}

If we had implemented the first of the two approaches, we could have made use of an existing Rust library to reduce the amount of boilerplate required to implement polymorphism.
This library operates on the basis that inheritance can be replicated via composition. If a data type were to contain a member that implements a given trait, there is no reason for that outer struct to not be able to implement that trait by simply calling upon the underlying member.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[inheritable]
            pub trait SEResource {
                fn href(&self) -> Option<&str>;
            }

            pub struct SEResourceObj {
                href: Option<String>
            }

            impl SEResource for ResourceObj {
                fn href(&self) -> Option<&str> {
                    self.href.as_str()
                }
            }
        \end{lstlisting}
        \label{fig:resinher}
        \caption{Rust code required to represent the IEEE 2030.5 "Resource" data type using 'inheritance-rs'}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Inheritance)]
            pub struct SEList {
                #[inherits(SEResource)]
                res: SEResourceObj,
                all: Uint32,
                results: Uint32,
            }
        \end{lstlisting}
        \label{fig:listinher}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} using 'inheritance-rs'}
    \end{center}
\end{figure}


Figures 6.3 and 6.4 show how this library, \texttt{inheritance-rs} \cite[]{inheritancers} is used to reduce the boilerplate necessary to inherit data members. 
In Figure 6.3, we mark the SEResource trait as 'inheritable' and then implement that trait on a type that holds the necessary members, our bare minimum 'base' type. 
In Figure 6.4, we compose an instance of that base type into a type that would normally inherit from it. Then, we tell the library to generate the code, at compile time, that would allow List to implement the SEResource trait.
This generated code simply calls the underlying SEResourceObj member when the href function would be called on a list.

The major flaw in this approach is that for every single type that is used as a base type, a trait, and a base implementation of that trait needs to be written.
Given that there are just under 700 data types in the IEEE 2030.5 schema, we had to consider alternatives.


\subsubsection{XSD to Rust types}

If we were to implement the second approach, an existing Rust library can be used to automate the process of defining data types altogether.
This of course draws on the fact that the IEEE 2030.5 XSD is entirely self-contained, and follows XSD guidelines by W3C. As such, generating rust data types from it is a reasonable approach.
One such way to automate this process would be to design and implement our own XSD parser, however, we are not the first to require this tool. 

On the Rust public crates registry there are several XSD parsers, many of which existing to solve very similar problems; implementing standardised communication protocols in Rust.
However, for that reason, many of these implementations are developed until they meet the creators needs, at which point the tool is no longer maintained.

Of the most complete parsers, one particular implementation stands out. This particular implementation supports hierarchial inheritance and makes reasonable assumptions on the internal representations of primitive data types.
\texttt{xsd-parser-rs} by \texttt{Lumeo}, was created for use in their \texttt{Open Network Video Interface Forum Client}, software with requirements not dissimilar from that of IEEE 2030.5. \cite[]{xsdparserrs}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Default, PartialEq, Debug, YaSerialize, YaDeserialize)]
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            pub struct List {
                // The number specifying "all" of the items in the list. 
                // Required on a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "all")]
                pub all: Uint32,
            
                // Indicates the number of items in this page of results.
                #[yaserde(attribute, rename = "results")]
                pub results: Uint32,
            
                // A reference to the resource address (URI). 
                // Required in a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "href")]
                pub href: Option<String>,
            }
        \end{lstlisting}
        \label{fig:listauto}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} as generated by \texttt{xsd-parser-rs}}
    \end{center}
\end{figure}

Figure 6.5 is what \texttt{xsd-parser-rs} currently produces for the List resource. In this figure, it's parsed that the List type inherits from the Resource type, and included the href data member accordingly. It's also included the documentation as found in the schema.

Compared to true OOP inheritance, this has types include their parent type data members in their own type definitions.
Despite this, the type definitions are far more readable, and align more closely with the output of the client, in that inheritance is flattened out.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <List xmlns="urn:ieee:std:2030.5:ns" all="0" results=0" 
            href="/sample/list/uri" />
        \end{lstlisting}
        \label{fig:listxml}
        \caption{An XML representation of an IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

Figure 6.6 shows the List data type were it a concrete data type serialized into XML.

Further advocating for the use of an XSD parser is the fact that the 2030.5 XSD is updated more often than revisions of the specification itself, even if those updates are relatively infrequent.
Using \texttt{xsd-parser-rs} will allow us to better maintain the client, by way of simply running updated schemas through the parser, should it change drastically as a result of a major revision (although this is unlikely).

Of course, \texttt{xsd-parser-rs} does not perfectly fit our needs. However, it is released under the MIT license, giving us the freedom to fork the library, and modify it to suit our needs. As part of our implementation we've:

\begin{itemize}
    \item Instructed it to use the Rust Option type where \texttt{minOccurs=0} and \texttt{maxOccurs=1}.
    \item Instructed it to provide us with all types in a type's inheritance tree.
    \item Manually implemented Rust enums for all types that are integer enumerations.
    \item Manually implemented Rust \texttt{bitflags} for all integer bitmap types.
    \item Modified the Derive output on all data types to automatically implement traits where useful.  
\end{itemize}

\subsubsection{Integer Bitmaps}
IEEE 2030.5, for the sake of efficiency, has many fields that encode many boolean values together in a single integer, a bitmap of booleans, or colloquially a 'bitflag'. Whilst we must still maintain how these integers are stored internally, we have the opportunity to provide them in a more ergonomic interface. Thus, we use the \texttt{bitflags} crate, a popular Rust crate that wraps integers and provides convenience functions for comparing them (intersections, unions), and constructing them using enum like syntax. \cite{bitflags}

\subsubsection{Resource Polymorphism}
As mentioned, we've used \texttt{xsd-parser-rs} to automate the process of resolving an inheritance tree in the XSD. This has enabled us to add polymorphism via base types to our implementation.

We add Resource polymorphism to our common library as it can be implemented relatively easily, and assists both ourselves in writing more generic code (such as the Event scheduler), and users of our library, such as by allowing them to store all "Subscribable" resources in a single container.

Therefore, as part of the common library, we define a set of Rust traits that mirror common fields in resources. 

Since IEEE 2030.5 does not use multiple inheritance (inheriting from more than one base type), if we were to mirror base types to traits exactly, we would be implementing a confusing level of redundancy into our traits.
For example, \texttt{RespondableSubscribableIdentifiedObject} inherits from \texttt{RespondableSubscribableObject}, providing it with three new fields that allow it to be 'Identified'. Similarly, \texttt{RespondableIdentifiedObject} inherits from \texttt{RespondableObject}, also providing it with the Identified fields. In this example, Resources become 'identified' in two different ways. Rather than have two traits that provide the same behaviour, but with two different supertraits, we simplify and provide a single \texttt{SEIdentifiedObject} trait. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            trait SEIdentifiedObject: SEResource {
                fn mrid(&self) -> &MRIDType;
                fn description(&self) -> Option<&String32>;
                fn version(&self) -> Option<VersionType>;
            }
        \end{lstlisting}
        \label{fig:identtrait}
        \caption{Our implementation of the IdentifiedObject trait}
    \end{center}
\end{figure}

To implement these traits for all relevant types we use Rust's procedural macros - Rust code that runs at compile time producing more code to be compiled. A straight forward implementation gives us the ability to derive any of these traits on a type that possesses all the required fields.

Manually adding these Derive annotations to all our data types is unfeasible. Instead, we use our \texttt{xsd-parser-rs} fork to evaluate all the inheritance in the inheritance tree of a specific type, and use it to automate this process entirely. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                SERandomizableEvent,
                SEEvent,
                SERespondableSubscribableIdentifiedObject,
                SEIdentifiedObject,
                SESubscribableResource,
                SERespondableResource,
                SEResource,
            )]
            struct EndDeviceControl { ... }
        \end{lstlisting}
        \label{fig:edctraits}
        \caption{The output of \texttt{xsd-parser-rs} for \texttt{EndDeviceControl}}
    \end{center}
\end{figure}

The result is all IEEE 2030.5 resources include trait implementations defining behaviour shared between them. 



\subsection{Resource Serialisation \& Deserialisation}
IEEE 2030.5 resources can be sent as their XML representations over HTTP. This means our common library requires the ability to serialize and deserialize resources to and from the appropriate XML.
This means HTTP requests containing resources are sent with \texttt{Content-Type} set to \texttt{application/sep+xml}.

On the public Rust crates registry, there exists a popular XML serialisation and serialization library purpose built for use in embedded communication protocols called \texttt{YaSerde} \cite[]{YaSerde}.
Despite being developed by different teams, the syntax to use \texttt{YaSerde} on Rust data types is auto-generated by \texttt{xsd-parser-rs}, and as such, is to be used in our client implementation.

Referring again to Figure 6.5, we see \texttt{xsd-parser-rs} has qualified our struct with the appropriate namespace, such that YaSerde serializations will include it, and deserializations will expect it.
Furthermore, names of data members have been specified as attributes, rather than child elements in the resulting XML; determined by the parser as per the XSD.
Figure 6.6 is an example of what the List type looks like when serialized to XML.

\texttt{YaSerde} does not perfectly fit our needs. However, it is also released under the MIT license, giving us the freedom to fork it, and add our required functionality.
As part of our work we've modified \texttt{YaSerde} (\texttt{SEPSerde}) in order to:

\begin{itemize}
    \item Serialize Rust enums as their underlying integer representations.
    \item Allow for Rust trait objects (dynamic dispatch) to be created on the serialize and deserialize traits.
    \item Serialize and deserialize IEEE 2030.5 \texttt{HexBinary} primitives as hexadecimal with an even number of digits. 
    \item Allow \texttt{bitflags} generated bitmaps to be serialized and deserialized.
    \item Allow for generic resources to be serialized and deserialized (Notification)
\end{itemize}

\subsubsection{Notification}
The 'Notification' resource is a container for delivering resources to clients via the Subscription / Notification method. This means a Notification resource is generic, it contains some other resource as one of it's fields. To represent this as a type, we use Rust generics, where the generic type is bound by the 'SEResource' trait we've defined.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            struct Notification<T: SEResource> {
                resource: Option<T>,
                ...
            }
        \end{lstlisting}
        \label{fig:notifgeneric}
        \caption{Notification resource implemented using Rust generics}
    \end{center}
\end{figure}

This type representation uses Rust's monomorphization, and therefore has no runtime overhead in order to make the Resource type generic.

However, this poses some challenges for \texttt{YaSerde} which was not written with this sort of use case in mind. Even more so, the XML representation of a Notification resource is unique, in terms of how it expresses the type of the inner resource.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
        <Notification xmlns="urn:ieee:std:2030.5:ns" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <subscribedResource>/upt/0/mr/4/r</subscribedResource>
            <Resource xsi:type="Reading">
                <timePeriod>
                    <duration>0</duration>
                    <start>12987364</start>
                </timePeriod>
                <value>1001</value>
            </Resource>
            <status>0</status>
            <subscriptionURI>/edev/8/sub/5</subscriptionURI>
        </Notification>        
        \end{lstlisting}
        \label{fig:notifxml}
        \caption{Example Notification<Reading> resource from IEEE 2030.5}
    \end{center}
\end{figure}

Figure 6.10 shows a Notification resource that contains a Reading resource. Of interest is that the inner resource is always contained in an XML element with the name "Resource", and the type of the inner resource is instead given by the 'type' attribute, provided by the \texttt{XMLSchema-Instance} namespace. 

The implication of this is not only do we need to modify \texttt{SEPSerde} to handle generic resources, but we also need a way to instruct it to add this  \texttt{xsi:type} attribute accordingly.

When setting the \texttt{xsi:type} attribute, we note that we require the name of the resource as a String. This means for every resource we also need to somehow bundle along with it a string literal of the name of the type. We do this by having the procedural macro responsible for generating the serialisation code also define a function that contains that string literal.

Throughout our implementation, we've also found additional use for this function, using it to provide the name of the resource as additional context when creating logs in generic functions.

In order to instruct \texttt{SEPSerde} to place this \texttt{xsi:type} attribute as required, we add a new procedural macro attribute to the library, \texttt{generic}.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                YaSerialize, YaDeserialize, SESubscriptionBase, SEResource,
            )]
            #[yaserde(
                namespace = "urn:ieee:std:2030.5:ns",
                namespace = "xsi: http://www.w3.org/2001/XMLSchema-instance"
            )]
            pub struct Notification<T: SEResource> {
                #[yaserde(rename = "Resource")]
                #[yaserde(generic)]
                pub resource: Option<T>,
                ...
            }    
        \end{lstlisting}
        \label{fig:notifimpl}
        \caption{Our Notification resource implementation}
    \end{center}
\end{figure}

Figure 6.11 this in use, we append the additional namespace as required, and include the \texttt{generic} annotation. The result is that an instance of a \texttt{Notification<T: SEResource>} serialises and deserialises successfully. 


\subsubsection{NotificationList}
Unlike the Notification resource, the NotificationList resource's purpose are more ambiguous. In IEEE 2030.5 a NotificationList resource is described as a "List of Notifications" and that it is a "List Resource that supports multiple types". This could be interpreted in a few ways:

\begin{itemize}
    \item Each Notification in a Notification List can contain a different inner resource
    \item All Notifications in a NotificationList must contain the same resource
    \item A NotificationList is a Notification of a List resource, where that List resource is split up into multiple individual notifications.
\end{itemize}

The latter two interpretations would lead themselves to the most trivial implementation, a NotificationList need simply have a single generic type. The first interpretation would be, as a result of Rust's type-system, very much non-trivial, and would require each Notification to store a SEResource trait object (dynamic dispatch), as to force each Notification to have the same concrete type.
Fortunately, as mentioned in 5.2.1 we assume developers would want to use different routes for different notifications, making the first interpretation irrelevant.

However, that does not yet clarify which of the latter two are correct. In any case, this is merely the behaviour of the NotificationList after being deserialised, and not something we as library developers need to worry about. For that reason we implement NotificationList as simply a list of Notifications, all with the same inner resource.

\subsubsection{Exploring Dynamic Deserialisation}
Dynamic deserialisation was a feature we explored implementing in our \texttt{YaSerde} fork; the ability to determine how a given XML string should be deserialised at runtime, instead of having to know at compile-time, as it is now.

The protocol's WADL XML document outlines all the routes a IEEE 2030.5 server can provide, and what type of resource is expected on that route. Coupled with the assumption that library users implementing the Subscription / Notification will use different routes for different incoming resources, we can deduce that the type of all incoming XML resources can be determined at compile time, and thus the need to inspect Resources and determine how they should be deserialised isn't at all necessary. 

Regardless, as part of this thesis we explored how this might be accomplished in Rust, in order to determine if it would work to improve the ergonomics of our common library interface.

In order to have a Rust function that deserialise all valid resources, even if the type is not known, we require that the function returns a single concrete type. For this we could use trait objects, Rust dynamic dispatch, which has the function return a 'fat' pointer, which contains a pointer to the resource (usually on the heap) and pointer to the table containing function pointers for the corresponding trait, often called a 'vtable' or 'virtual method table'. 

Implementing this function with a trait object return type would require a significant time investment, adjusting the existing \texttt{YaSerde} code to have it it return a \texttt{Box<T>} (heap allocated), instead of \texttt{T} (stack allocated).

An alternative to using trait objects would be to have a Rust tagged union (an enum) of all (141) top-level resource typess. Every resource would therefore have the same concrete type once wrapped in that enum.

Regardless of the approach, we would also need to implement some form of lookup mapping the names of resources to code that deserialize based off the type of the resource - which we could likely auto-generate.

If a trait object was used, the return type of the function doesn't provide users with anything immediately useful, in order to inspect the contents of the resource, they would need to downcast the trait object to a concrete type, which requires them to first know the concrete type at compile-time, bringing us back to the original problem.

The Rust enum approach improves this situation. When combined with Rust match statements library users can filter to a concrete resource as needed. However, with 141 different resources it's likely this filtering would be very verbose. Given that client developers should know the type of all incoming resources at compile time, implementing this functionality ourselves would force library users to handle this filtering themselves, even if they don't necessarily require it.

For that reason, we won't be implementing any form of run-time deserialisation. If users require any of the approaches we've discussed, they have the ability to implement it themselves, or more reasonably, switch to a dynamically typed language where this model can be more easily supported, as we saw in the \texttt{envoy-client}.

\subsection{List Ordering}
IEEE 2030.5 defines list resources as simply a list of resources that can be retrieved in a single request. For each list resource, the specification defines how the list should be ordered, which values should be used as keys, and the precedence of those keys. \cite{IEEE2030.5}

Therefore, for all resources that are used in a list we've implemented the Rust \texttt{Ord} trait, which defines a total order (as opposed to a partial order), that will be used when using default sort methods on the list itself.

Unfortunately, this is not described in any standardised way, and was instead implemented manually.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            impl Ord for DERControl {
                fn cmp(&self, other: &Self) -> std::cmp::Ordering {
                    // Primary Key - primacy (ascending)
                    match self.interval.start.cmp(&other.interval.start) {
                        core::cmp::Ordering::Equal => {}
                        ord => return ord,
                    }
                    // Secondary Key - creationTime (descending)
                    match self.creation_time.cmp(&other.creation_time).reverse() {
                        core::cmp::Ordering::Equal => {}
                        ord => return ord,
                    }
                    // Tertiary Key - mRID (descending)
                    self.mrid.cmp(&other.mrid).reverse()
                }
            } 

            impl PartialOrd for DERControl {
                fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                    Some(self.cmp(other))
                }
            }
        \end{lstlisting}
        \label{fig:dercord}
        \caption{Our ordering implementation for the DERControl trait}
    \end{center}
\end{figure}

Figure 6.12 shows our implementation of this, where we first implement a total order, and then use that to implement the required partial order.

To provide an ergonomic way for working with lists, and ensure lists are always sorted, we use our procedural macros to provide a common interface for working with list resources. List resources contain a Rust \texttt{Vec} internally, which can be pushed to directly, but does not retain the sortedness.

Instead, we provide a \texttt{add} function on all lists that inserts and retains the intended order. This function also updates the 'all' field of the resource (the length of the list), to ensure it remains consistent with the actual contents of the list. Similarly, we provide a \texttt{remove} function. For all other, less common use cases, library users will be required to update the list invariants as necessary. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEList: SEResource {
                type Inner: Ord;
                fn all(&self) -> Uint32;
                fn all_mut(&mut self) -> &mut Uint32;
                fn results(&self) -> Uint32;
                fn results_mut(&mut self) -> &mut Uint32;
                fn list_as_slice(&self) -> &[Self::Inner];
                fn list_mut(&mut self) -> &mut Vec<Self::Inner>;
            
                /// Add an item to the contained list, maintaining invariants
                fn add(&mut self, item: Self::Inner) {
                    self.list_mut().push(item);
                    // 'very fast in cases where the slice is nearly sorted'
                    self.list_mut().sort();
                    *self.all_mut() = Uint32(self.all().get() + 1);
                }
                
                ///Remove an item from the contained list, maintaining invariants
                fn remove(&mut self, idx: usize) -> Self::Inner {
                    *self.all_mut() = Uint32(self.all().get() - 1);
                    self.list_mut().remove(idx)
                }
        \end{lstlisting}
        \label{fig:listtraitimpl}
        \caption{Our SEList trait, with default add and remove methods.}
    \end{center}
\end{figure}

\subsection{CSIP-AUS}
Implemented in \texttt{sep2\_common} are the IEEE 2030.5 extensions required by CSIP-AUS. These take the form of two additional resources, and additional fields on existing resources. When extensions are used, IEEE 2030.5 requires that the XML namespace for the extension be included with the resource, and that extension specific fields be prefixed accordingly. For CSIP-AUS this is the \texttt{https://csipaus.org/ns} namespace, and the \texttt{csipaus} prefix. \cite{CSIPAus}

We make CSIP-AUS extensions available behind the \texttt{csip\_aus} crate feature (crate compile flag). When activated, the Rust compiler adds the namespace to existing IEEE 2030.5 resources, and adds the prefix to their respective fields. It also makes the new resources available for use, also with the correct namespace and prefix. Using existing functionality of \texttt{YaSerde}, adding these extensions is straight-forward.

As per the Energy Queensland SEP2 Client Handbook, and the CSIP-AUS publication by ARENA, these resources, and our support for the client aggregation model, are the extent to which we as library developers can assist users in developing CSIP-AUS compliant clients. \cite{sep2clienthandbook} \cite{CSIPAus}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            #[cfg_attr(
                feature = "csip_aus",
                yaserde(namespace = "csipaus: https://csipaus.org/ns")
            )]
            pub struct DERCapability {
                /// Bitmap indicating the CSIP-AUS controls implemented
                #[cfg(feature = "csip_aus")]
                #[yaserde(rename = "doeModesSupported")]
                #[yaserde(
                    prefix = "csipaus", 
                    namespace = "csipaus: https://csipaus.org/ns"
                )]
                pub doe_modes_supported: DOEControlType,
                ...
            }
        \end{lstlisting}
        \label{fig:csipausimpl}
        \caption{The DERCapability annotated with optional CSIP-AUS extensions.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <EndDevice xmlns="urn:ieee:std:2030.5:ns" 
                       xmlns:csipaus="https://csipaus.org/ns">
                <changedTime>0</changedTime>
                <csipaus:ConnectionPointLink  href="/edev/1/cp" />
                <sFDI>0</sFDI>
            </EndDevice>
        \end{lstlisting}
        \label{fig:enddeviceconnpointxml}
        \caption{Example XML representation of an EndDevice resource with a CSIP-AUS ConnectionPointLink.}
    \end{center}
\end{figure}

Figure 6.15 shows the output of our common library when an EndDevice is constructed with a ConnectionPointLink resource, and when the \texttt{csip\_aus} compile flag is enabled.


\subsection{MRID Generation}
IEEE 2030.5 Servers and Clients are both capable of creating resources. Resources where multiple instances can exist contain a "Master Resource Identifier" or an "MRID", a 128 bit integer that is globally unique.
As such, library users will require a way of reliably creating cryptographically unique MRIDs. One requirement of the MRIDs is that they contain a IANA Private Enterprise Number (PEN) in the least significant 32 bits of the MRID.

For that reason, we provide users of our library with a function with the signature \texttt{fn mrid\_gen(pen\_id: u32) -> MRIDType} that produces a new MRID each time it's called.

IEEE 2030.5 provides the requirement that MRIDs are sufficiently cryptographically unique, where the risk of an MRID collision is minimised. The EPRI C implementation defines an algorithm for generating MRIDs that ensures, at the very minimum, that two MRIDs produced by a single instance of the program will never collide, by use of a global, mutable, atomic integer that increments each ID. Since EPRI was able to release their MRID generation algorithm as part of their library, we assume it's sufficient, and implement a very similar algorithm in Rust.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            static MRID_COUNT: AtomicU32 = AtomicU32::new(0);

            fn mrid_gen(pen_id: u32) -> MRIDType {
                let id: u128 = /* Generate Random u128 */
                let time: u128 = /* Get Unix Timestamp */
                let count: u128 = /* Fetch and increment MRID_COUNT */
                HexBinary128((time << 32) 
                            | (id << 32) | (count << 32) 
                            | pen_id as u128)
            }
        \end{lstlisting}
        \label{fig:mridgenalgo}
        \caption{Our implementation of an MRID generator, inspired by EPRI's.}
    \end{center}
\end{figure}


Going forward, it would be ideal to calculate the possibility of a global collision with this algorithm, as to verify that is is sufficiently cryptographically unique, however, this is out of scope of this thesis.

\subsection{Testing}
\texttt{sep2\_common} is developed alongside a suite of tests, ensuring all resources can be serialised and deserialised, and that their XML representations adhere to IEEE 2030.5.

\subsubsection{MRID Generation}
We provide a test verifying that the PEN ID can be obtained from a given MRID, and that there are no collisions when generating several million MRIDs on a single instance of the program. This is to be expected, as we use include a global, mutable counter in the final value.

\subsubsection{Testing SEPSerde}
As expected, by the nature of serialisation and deserialisation, we have no compile time guarantees either will succeed for a given data type.
Therefore, our first test suite for the common library is to test that all data types can be serialized \& deserialized successfully, and that it can be done without any data loss.

\begin{figure}[h]
    \begin{center}
        \begin{lstlisting}
            #[test]
            fn default_List() {
                let og = List::default();
                let new: List = deserialize(serialize(orig).unwrap()).unwrap();
                assert_eq!(orig, new);
            }
        \end{lstlisting}
        \label{fig:yaserdetest}
        \vspace{-10pt}
        \caption{A Rust test verifying that the IEEE 2030.5 List resource can be serialized \& deserialized}
    \end{center}
\end{figure}

The logic for a test of this type can be succinctly expressed in Rust, as seen in Figure 5.7. 
This test takes advantage of the fact that all our resources are able to automatically implement the 'default' trait, and as such an instance of any resource can be instantiated with default values.
In Figure 5.7, we first perform this default instantiation, convert the resource to an XML string, and then convert the XML string back into our internal List representation. 
Finally, we check if the newly deserialized resource is equal to it's default.

For each resource, the only part of this test that differs is the name of the type. As such, we auto-generate this test for each resource, and include it in \texttt{sep2\_common}.

\subsubsection{XML Correctness}
The remainder of the common library will be tested by ensuring representations of resources are correct with respect to those defined in IEEE 2030.5.
These tests use the example XML resources provided as part of IEEE 2030.5 as a starting point, as they are more likely to be correct than resources we would write by hand. However, the scope of these examples is narrow, and we are required to write more going forward.

\section{Client Library}
The client library, \texttt{sep2\_client}, contains the remainder of our implementation, and provides an interface for interacting with IEEE 2030.5 servers, as well as interfaces for handling Event resources, the Time function set, and an implementation of the Subscription / Notification mechanism. 

\subsection{Application Support}
In IEEE 2030.5, the Application Support function set is defined to include: \cite{2030}

\begin{itemize}
    \item "RESTful HTTP/1.1 application data exchange semantics"
    \item 'XML and/or EXI encoding as the data payload of RESTful operations'
    \item "Authentication and encryption as HTTP over TLS " (Security Function Set)
\end{itemize}

As such, this function set relies on a correct implementation of other standardised functionality. We choose to implement these standards by leveraging well-tested \& open-source implementations of HTTP, XML, and TCP.

\subsubsection{XML}
IEEE 2030.5 resources are serialised to XML via our \texttt{sep2\_common} crate, which depends on our \texttt{YaSerde} fork, \texttt{SEPSerde}. Internally, this uses the \texttt{xml-rs} crate, an XML parser \& writer \cite{xmlrs}. This library was chosen to due it's emphasis on specification adherence. In our research we found many competing libraries sacrifice correctness and completeness for performance, or are built for a specific usecase, and then no longer maintained. \cite{xmlrsperformance}

Going forward, it may be worthwhile to explore alternative XML libraries that can be substituted into \texttt{SEPSerde} with the goal of improving XML parsing and writing performance. 

\subsubsection{HTTP}
To communicate with IEEE 2030.5 servers using HTTP we use the Rust \texttt{hyper} library, as it currently integrates best with our Security function set requirements, and provides us with adherence to HTTP/1.1. \cite{hyper}

\subsubsection{TCP}
Clients and servers using HTTP/1.1 must use TCP. The most sensible approach to implementing TCP is to wrap the target operating system's sockets library. This is done for us by the Rust standard library.

\subsection{Security}
The security function set of IEEE 20305 involves "securing transactions between clients and servers" via HTTP over TLS, or more commonly referred to as HTTPS. IEEE 2030.5 mandates a variation of TLS, mTLS, be used. mTLS provides a mechanism for mutually authenticating clients and servers. 

The major constraint implementing the security function set is that "All devices SHALL support \texttt{TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8} cipher suite", and that the "ECC cipher suite SHALL use elliptic curve secp256r1".\cite{IEEE2030.5}

IEEE 2030.5 does allow for additional cipher suites to be used, provided they "provide a cryptographic strength at least equivalent to the mandatory cipher suite". \cite{IEEE2030.5} As it stands, users wishing to add additional cipher suites are required to modify the source code of our library, though we do not rule out the possibility of providing an interface for setting additional cipher suites in the future.

Additionally, IEEE 2030.5 defines six classes of X509 certificates, each with different restrictions on how they are to be signed, and what  X509 certificate extensions they contain, and how they are to be set.

Our client library provides developers with a generic interface for meeting the requirements of the Security function set.

\subsubsection{TLS via OpenSSL}
To implement TLS, we use the publicly audited, and commonly used library \texttt{OpenSSL}. \texttt{OpenSSL} is a C library, for which there exist popular Rust bindings that provide an (approximately) safe foreign function interface to the C library. \cite{openssl}

Our HTTP library \texttt{hyper} doesn't natively support OpenSSL, but accepts a generic connector interface for use with any conforming external TLS configuration. To accommodate for this, we have \texttt{OpenSSL} generate a TLS config and use the \texttt{hyper\_openssl} library to wrap that configuration in a connector that can be understood by \texttt{hyper}. \cite{hyperopenssl}

An \texttt{OpenSSL} TLS configuration is generated when a IEEE 2030.5 Client, capable of making HTTPS requests, is instantiated. To create an IEEE 2030.5 TLS configuration for use in a Client device, library users must provide:

\begin{itemize}
    \item The IP address of the target IEEE 2030.5 server for this client instance.
    \item Path to a IEEE 2030.5 "Device Certificate" or "Self-Signed Client Certificate" \texttt{.pem} file.
    \item Path to the certificate's corresponding private key \texttt{.pem} file.
    \item Path to a IEEE 2030.5 "Root certificate" \texttt{.pem} file. 
\end{itemize}

The relevant details on these certificate types are in IEEE 2030.5 \texttt{6.11.8.3.3}, \texttt{6.11.8.4.3} and \texttt{6.11.8.2}. We require the path to the CA to be supplied as to not require developers to install the CA on the system.

Client instances restricted to performing requests via HTTP can be instantiated with just a server address.

\begin{figure}[h]
    \begin{center}
        \begin{lstlisting}
            let client = Client::new_https(
                "https://127.0.0.1:1337",
                "client_cert.pem",
                "client_private_key.pem",
                "serca.pem",
                /* Additional configuration ... */
            )
        \end{lstlisting}
        \label{fig:httpsclientexample}
        \vspace{-10pt}
        \caption{Example IEEE 2030.5 Client instantiation}
    \end{center}
\end{figure}

\subsubsection{X509 Parsing \& Validation}
Additionally, we provide an interface for library users to verify that the provided X509 certificates adhere to the specification, that they contain specific extensions and fields. \texttt{OpenSSL} provides this functionality, however the Rust FFI bindings we use do not expose the corresponding API. Rather than write unsafe Rust FFI, and possibly introduce undefined behaviour to our library, we simply defer to the \texttt{X509-Parser} library, which lets us check these conditions efficiently. \cite{x509parser}

\begin{figure}[h]
    \begin{center}
        \begin{lstlisting}
            fn check_device_cert(cert: impl AsRef<Path>) -> Result<()>;
            fn check_self_signed_cert(cert: impl AsRef<Path>) -> Result<()>;
            fn check_ca(cert_path: impl AsRef<Path>) -> Result<()>;
        \end{lstlisting}
        \label{fig:certvalidinterface}
        \vspace{-10pt}
        \caption{Our IEEE 2030.5 certificate validation interface}
    \end{center}
\end{figure}

We distinguish between IEEE 2030.5 'device certificates', and 'self signed client certificates', as they have different requirements. Furthermore, the Subscription / Notification mechanism forbids the use of the latter.

\subsection{Core Client Functionality}

\subsection{Resource Polling}

\subsection{Subscription / Notification}

\subsection{Time}

\subsection{Event Schedules}

\subsection{Logging}

\subsection{Testing}

\subsubsection{Security}
During development, we maintained a local certificate authority via the tool \texttt{mkcert}. However, this tool is not capable of producing certificates that match those required by IEEE 2030.5
In order to properly test our Security function set, we required TLS certificates as close as possible to those used in the real world; certificates that include all the relevant X509 extensions, and are generated using the specified elliptic curve, and are compatible with the mandatory cipher suite. For this reason, we consult the SunSpec Alliance, who provide free IEE 2030.5 test certificates upon request. As part of this thesis we have requested certificate packages for both our client, and test server, and have tested them when communicating resources, and our interface for parsing and validating X509 certificates.

However, these certificates do not provide us a way with interacting with any publicly accessible IEEE 2030.5 test servers. For that, we'll require test certificates from Energy Queensland, as discussed in TODO.









