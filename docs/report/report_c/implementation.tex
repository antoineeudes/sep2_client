\chapter{Implementation}\label{ch:implementation}
Given the context and background of the IEEE 2030.5 protocol, and the high-level design decisions we've been required to make, we can discuss the technical design decisions present in our final implementation.
\section{Common Library}

\subsection{Resource Data Types}
The largest aspect of this common library is the internal representation of resources, the data communicated between clients \& servers. These resources are described precisely in an XSD.
Resources range from data that may be used by the electric utility, such as the current load of the device, to resource metadata, such as the rate at which a client should poll a server for a given resource, or what URI endpoint can be used to access a given resource, in the case of a Link resource.
In both specification and schema, these data structures are separated into packages for each of the function sets.

Whilst the 2030.5 specification makes no mention of the object oriented programming paradigm, OOP inheritance underpins the design of all resources, including both multi-level and hierarchial inheritance.
As such, for the purpose of code reuse, many base types appear in the 'common' package; data structures extended by many others.

\subsubsection{Representing Resources in Rust}
Rust, despite being influenced by OOP, does not posses the notion of a class, like in languages like C++ or Java. As such, Rust does not define shared behaviour of types through inheritance from a common parent type. 
Rather shared behaviour is defined through traits, where shared behaviour refers solely to the methods that we can call on that type, the traits a type implements.

In this sense, Rust polymorphism does not concern itself with what a type is or what that type stores, it concerns itself only with the traits it possesses.

Traits themselves do support inheritance. One can have traits that require other traits to be implemented for a given type. However, this does not change the fact that traits only represent behaviour. 
There is no way to have a data structure inherit the internal members of another.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEResource {
                fn href(&self) -> Option<&str>;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 "Resource" data type}
    \end{center}
\end{figure}



\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            pub trait SEList: SEResource {
                fn all(&self) -> Uint32;
                fn results(&self) -> Uint32;
            }
        \end{lstlisting}
        \caption{A Rust trait representing the IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

In Figure 5.2, we have a Rust trait that describes the behaviour of the List base type. All lists are resources, and thus we have a trait restriction that all types implementing List must first implement the Resource trait.

The prefix \texttt{SE} for 'Smart Energy' simply differentiates the trait from the concrete type with the same name.

This is the extent of native inheritance in rust. We can specify the exact behaviour of types that belong to a trait in detail, but we cannot influence how that behaviour is achieved.

\subsubsection{Emulating inheritance in Rust}

As a result, we're forced to emulate the inheritance of data structure members in Rust, of which there are two approaches:

\begin{itemize}
    \item Composite an instance of the base type into type definitions 
    \item Repeat all inherited members in type definitions
\end{itemize}

Regardless of the approach, we still do not have have polymorphism using the base-types of resources.
To allow for polymorphism a trait must be defined for each base-type, and then those trait functions need be implemented for every type that extends that base type. 
This is unavoidable duplicate code, although Rust provides mechanisms for which it can be generated at compile-time.

\subsubsection{Inheritance via Composition}

If we had implemented the first of the two approaches, we could have made use of an existing Rust library to reduce the amount of boilerplate required to implement polymorphism.
This library operates on the basis that inheritance can be replicated via composition. If a data type were to contain a member that implements a given trait, there is no reason for that outer struct to not be able to implement that trait by simply calling upon the underlying member.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[inheritable]
            pub trait Resource {
                fn get_href(&self) -> Option<&str>;
            }

            pub struct ResourceObj {
                href: Option<String>
            }

            impl Resource for ResourceObj {
                fn href(&self) -> Option<&str> {
                    self.href.as_str()
                }
            }
        \end{lstlisting}
        \label{fig:resinher}
        \caption{Rust code required to represent the IEEE 2030.5 "Resource" data type using 'inheritance-rs'}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Inheritance)]
            pub struct List {
                #[inherits(Resource)]
                res: ResourceObj,
                all: UInt32,
                results: UInt32,
            }
        \end{lstlisting}
        \label{fig:listinher}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} using 'inheritance-rs'}
    \end{center}
\end{figure}


Figures 6.3 and 6.4 show how this library, 'inheritance-rs' \cite[]{inheritancers} is used to reduce the boilerplate necessary to inherit data members. 
In Figure 6.3, we mark the Resource trait as 'inheritable' and then implement that trait on a type that holds the necessary members, our bare minimum 'base' type. 
In Figure 6.4, we compose an instance of that base type into a type that would normally inherit from it. Then, we tell the library to generate the code, at compile time, that would allow List to implement the Resource trait.
This generated code simply calls the underlying ResourceObj member when the href function would be called on a list.

The major flaw in this approach is that for every single type that is used as a base type, a trait, and a base implementation of that trait needs to be written.
Given that there are just under 700 data types in the IEEE 2030.5 schema, we had to consider alternatives.


\subsubsection{XSD to Rust types}

If we were to implement the second approach, an existing Rust library can be used to automate the process of defining data types altogether.
This of course draws on the fact that the IEEE 2030.5 XSD is entirely self-contained, and follows XSD guidelines by W3C. As such, generating rust data types from it is a reasonable approach.
One such way to automate this process would be to design and implement our own XSD parser, however, we are not the first to require this tool. 

On the Rust public crates registry there are several XSD parsers, many of which existing to solve very similar problems; implementing standardised communication protocols in Rust.
However, for that reason, many of these implementations are developed until they meet the creators needs, at which point the tool is no longer maintained.

Of the most complete parsers, one particular implementation stands out. This particular implementation supports hierarchial inheritance and makes reasonable assumptions on the internal representations of primitive data types.
\texttt{xsd-parser-rs} by \texttt{Lumeo}, was created for use in their \texttt{Open Network Video Interface Forum Client}, software with requirements not dissimilar from that of IEEE 2030.5. \cite[]{xsdparserrs}

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(Default, PartialEq, Debug, YaSerialize, YaDeserialize)]
            #[yaserde(namespace = "urn:ieee:std:2030.5:ns")]
            pub struct List {
                // The number specifying "all" of the items in the list. 
                // Required on a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "all")]
                pub all: Uint32,
            
                // Indicates the number of items in this page of results.
                #[yaserde(attribute, rename = "results")]
                pub results: Uint32,
            
                // A reference to the resource address (URI). 
                // Required in a response to a GET, ignored otherwise.
                #[yaserde(attribute, rename = "href")]
                pub href: Option<String>,
            }
        \end{lstlisting}
        \label{fig:listauto}
        \caption{A Rust data type representing an IEEE 2030.5 \texttt{List} as generated by \texttt{xsd-parser-rs}}
    \end{center}
\end{figure}

Figure 6.5 is what \texttt{xsd-parser-rs} currently produces for the List resource. In this figure, it's parsed that the List type inherits from the Resource type, and included the href data member accordingly. It's also included the documentation as found in the schema.

Compared to true OOP inheritance, this has types include their parent type data members in their own type definitions.
Despite this, the type definitions are far more readable, and align more closely with the output of the client, in that inheritance is flattened out.


\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            <List xmlns="urn:ieee:std:2030.5:ns" all="0" results=0" 
            href="/sample/list/uri" />
        \end{lstlisting}
        \label{fig:listxml}
        \caption{An XML representation of an IEEE 2030.5 \texttt{List} data type}
    \end{center}
\end{figure}

Figure 6.6 shows the List data type were it a concrete data type serialized into XML.

Further advocating for the use of an XSD parser is the fact that the 2030.5 XSD is updated more often than revisions of the specification itself, even if those updates are relatively infrequent.
Using \texttt{xsd-parser-rs} will allow us to better maintain the client, by way of simply running updated schemas through the parser, should it change drastically as a result of a major revision (although this is unlikely).

Of course, \texttt{xsd-parser-rs} does not perfectly fit our needs. However, it is released under the MIT license, giving us the freedom to fork the library, and modify it to suit our needs. As part of our implementation we've:

\begin{itemize}
    \item Instructed it to use the Rust Option type where \texttt{minOccurs=0} and \texttt{maxOccurs=1}.
    \item Instructed it to provide us with all types in a type's inheritance tree.
    \item Manually implemented Rust enums for all types that are integer enumerations.
    \item Manually implemented Rust \texttt{bitflags} for all integer bitmap types.
    \item Modified the Derive output on all data types to automatically implement traits where useful.  
\end{itemize}

\subsubsection{Integer Bitmaps}
IEEE 2030.5, for the sake of efficiency, has many fields that encode many boolean values together in a single integer, a bitmap of booleans, or colloquially a 'bitflag'. Whilst we must still maintain how these integers are stored internally, we have the opportunity to provide them in a more ergonomic interface. Thus, we use the \texttt{bitflags} crate, a popular Rust crate that wraps integers and provides convenience functions for comparing them (intersections, unions), and constructing them using enum like syntax. \cite{bitflags}

\subsubsection{Resource Polymorphism}
As mentioned, we've used \texttt{xsd-parser-rs} to automate the process of resolving an inheritance tree in the XSD. This has enabled us to add polymorphism via Resource base types to our implementation.

We add Resource polymorphism to our common library as it can be implemented relatively easily, and assists both ourselves in writing more generic code (such as the Event scheduler), and users of our library, such as by allowing them to store all "Subscribable" resources in a single container.

Therefore, as part of the common library, we define a set of Rust traits that mirror common fields in resources. 

Since IEEE 2030.5 does not use multiple inheritance (inheriting from more than one base type), if we were to mirror base types to traits exactly, we would be implementing a confusing level of redundancy into our traits.
For example, \texttt{RespondableSubscribableIdentifiedObject} inherits from \texttt{RespondableSubscribableObject}, providing it with three new fields that allow it to be 'Identified'. Similarly, \texttt{RespondableIdentifiedObject} inherits from \texttt{RespondableObject}, also providing it with the Identified fields. In this example, Resources become 'identified' in two different ways. Rather than have two traits that provide the same behaviour, but with two different supertraits, we simplify and provide a single \texttt{SEIdentifiedObject} trait. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            /// Implemented by all types whose base type is [`IdentifiedObject`]
            trait SEIdentifiedObject: SEResource {
                fn mrid(&self) -> &MRIDType;
                fn description(&self) -> Option<&String32>;
                fn version(&self) -> Option<VersionType>;
            }
        \end{lstlisting}
        \label{fig:identtrait}
        \caption{Our implementation of the IdentifiedObject trait}
    \end{center}
\end{figure}

To implement these traits for all relevant types we use Rust's procedural macros - Rust code that runs at compile time producing more code to be compiled. A straight forward implementation gives us the ability to derive any of these traits on a type that possesses all the required fields.

Manually adding these Derive annotations to all our data types is unfeasible. Instead, we use our \texttt{xsd-parser-rs} fork to evaluate all the inheritance in the inheritance tree of a specific type, and use it to automate this process entirely. 

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                SERandomizableEvent,
                SEEvent,
                SERespondableSubscribableIdentifiedObject,
                SEIdentifiedObject,
                SESubscribableResource,
                SERespondableResource,
                SEResource,
            )]
            struct EndDeviceControl { ... }
        \end{lstlisting}
        \label{fig:edctraits}
        \caption{The output of \texttt{xsd-parser-rs} for \texttt{EndDeviceControl}}
    \end{center}
\end{figure}

The result is all IEEE 2030.5 resources include trait implementations defining behaviour shared between them. 



\subsection{Resource Serialisation \& Deserialisation}
IEEE 2030.5 resources can be sent as their XML representations over HTTP. This means our common library requires the ability to serialize and deserialize resources to and from the appropriate XML.
This means HTTP requests containing resources are sent with \texttt{Content-Type} set to \texttt{application/sep+xml}.

On the public Rust crates registry, there exists a popular XML serialisation and serialization library purpose built for use in embedded communication protocols called \texttt{YaSerde} \cite[]{YaSerde}.
Despite being developed by different teams, the syntax to use \texttt{YaSerde} on Rust data types is auto-generated by \texttt{xsd-parser-rs}, and as such, is to be used in our client implementation.

Referring again to Figure 6.5, we see \texttt{xsd-parser-rs} has qualified our struct with the appropriate namespace, such that YaSerde serializations will include it, and deserializations will expect it.
Furthermore, names of data members have been specified as attributes, rather than child elements in the resulting XML; determined by the parser as per the XSD.
Figure 6.6 is an example of what the List type looks like when serialized to XML.

\texttt{YaSerde} does not perfectly fit our needs. Once again, it is released under the MIT license, giving us the freedom to fork it, and add our required functionality.
As part of our work we've modified \texttt{YaSerde} (\texttt{sepserde}) in order to:

\begin{itemize}
    \item Serialize Rust enums as their underlying integer representations.
    \item Allow for Rust trait objects (dynamic dispatch) to be created on the serialize and deserialize traits.
    \item Serialize and deserialize IEEE 2030.5 \texttt{HexBinary} primitives as hexadecimal with an even number of digits. 
    \item Allow \texttt{bitflags} generated bitmaps to be serialized and deserialized.
    \item Allow for generic resources to be serialized and deserialized (Notification)
\end{itemize}

\subsubsection{Notification}
The 'Notification' resource is a container for delivering resources to clients via the Subscription / Notification method. This means a Notification resource is generic, it contains some Resource as one of it's fields. To represent this as a type, we use Rust generics, where the generic type is bound by the 'SEResource' trait we've defined.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            struct Notification<T: SEResource> {
                resource: Option<T>,
                ...
            }
        \end{lstlisting}
        \label{fig:notifgeneric}
        \caption{Notification resource implemented using Rust generics}
    \end{center}
\end{figure}

This type representation uses Rust's monomorphization, and therefore has no runtime overhead in order to make the Resource type generic.

However, this poses some challenges for \texttt{YaSerde} which was not written with this sort of use case in mind. Even more so, the XML representation of a Notification resource is unique, in terms of how it expresses the type of the inner resource.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
        <Notification xmlns="urn:ieee:std:2030.5:ns" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <subscribedResource>/upt/0/mr/4/r</subscribedResource>
            <Resource xsi:type="Reading">
                <timePeriod>
                    <duration>0</duration>
                    <start>12987364</start>
                </timePeriod>
                <value>1001</value>
            </Resource>
            <status>0</status>
            <subscriptionURI>/edev/8/sub/5</subscriptionURI>
        </Notification>        
        \end{lstlisting}
        \label{fig:notifxml}
        \caption{Example Notification<Reading> resource from IEEE 2030.5}
    \end{center}
\end{figure}

Figure 6.10 shows a Notification resource that contains a Reading resource. Of interest is that the inner resource is always contained in an XML element with the name "Resource", and the type of the inner resource is instead given by the 'type' attribute, provided by the \texttt{XMLSchema-Instance} namespace. 

The implication of this is not only do we need to modify \texttt{sepserde} to handle generic resources, but we also need a way to instruct it to add this  \texttt{xsi:type} attribute accordingly.

When setting the \texttt{xsi:type} attribute, we note that we require the name of the resource as a String. This means for every Resource we also need to somehow bundle along with it a string literal of the name of the type. We do this by having the procedural macro responsible for generating the serialisation code also define a function that contains that string literal.

Throughout our implementation, we've also found additional use for this function, using it to provide the name of the resource as additional context when creating logs in generic functions.

In order to instruct \texttt{sepserde} to place this \texttt{xsi:type} attribute as required, we add a new procedural macro attribute to the library, \texttt{generic}.

\begin{figure}[H]
    \begin{center}
        \begin{lstlisting}
            #[derive(
                YaSerialize, YaDeserialize, SESubscriptionBase, SEResource,
            )]
            #[yaserde(
                namespace = "urn:ieee:std:2030.5:ns",
                namespace = "xsi: http://www.w3.org/2001/XMLSchema-instance"
            )]
            pub struct Notification<T: SEResource> {
                #[yaserde(rename = "Resource")]
                #[yaserde(generic)]
                pub resource: Option<T>,
                ...
            }    
        \end{lstlisting}
        \label{fig:notifimpl}
        \caption{Our Notification resource implementation}
    \end{center}
\end{figure}

Figure 6.11 this in use, we append the additional namespace as required, and include the \texttt{generic} annotation. The result is that an instance of a \texttt{Notification<T: SEResource>} serialises and deserialises successfully. 


\subsubsection{NotificationList}
Unlike the Notification resource, the NotificationList resource's purpose are more ambiguous. In IEEE 2030.5 a NotificationList resource is described as a "List of Notifications" and that it is a "List Resource that supports multiple types". This could be interpreted in a few ways:

\begin{itemize}
    \item Each Notification in a Notification List can contain a different inner resource
    \item All Notifications in a NotificationList must contain the same resource
    \item A NotificationList is a Notification of a List Resource, where that List resource is split up into multiple individual notifications.
\end{itemize}

The latter two interpretations would lead themselves to the most trivial implementation, a NotificationList need simply have a single generic type. The first interpretation would be, as a result of Rust's type-system, very much non-trivial, and would require each Notification to store a SEResource trait object (dynamic dispatch), as to force each Notification to have the same concrete type.
Fortunately, as mentioned in 5.2.1 we assume developers would want to use different routes for different notifications, making the first interpretation irrelevant.

However, that does not yet clarify which of the latter two are correct. In any case, this is merely the behaviour of the NotificationList after being deserialised, and not something we as library developers need to worry about. For that reason we implement NotificationList as simply a list of Notifications, all with the same inner resource.

\subsection{Testing}
The goal for this thesis is to produce a IEEE 2030.5 client that is well-tested for correctness, and conformance to the IEEE 2030.5 specification.
As such, our common library will be developed alongside a suite of tests, written with the goal to maximise code coverage, measured by lines of code.
All testing for the Common Library will be done via unit testing.

\subsubsection{Testing YaSerde}
As expected, by the nature of serialisation and deserialisation, we have no compile time guarantees either will succeed for a given data type.
Therefore, our first test suite for the common library is to test that all data types can be serialized \& deserialized successfully, and that it can be done without any data loss.

\begin{figure}[h]
    \begin{center}
        \begin{lstlisting}
            #[test]
            fn list_serde() {
                let orig = List::default();
                let new: List = from_str(&to_string_with_config(&orig, &YASERDE_CFG).unwrap()).unwrap();
                assert_eq!(orig,new)
            }
        \end{lstlisting}
        \label{fig:yaserdetest}
        \vspace{-10pt}
        \caption{A Rust test verifying that the IEEE 2030.5 List resource can be serialized \& deserialized}
    \end{center}
\end{figure}

The logic for a test of this type can be succinctly expressed in Rust, as seen in Figure 5.7. 
This test takes advantage of the fact that all our resources are able to automatically implement the 'default' trait, and as such an instance of any resource can be instantiated with default values.
In Figure 5.7, we first perform this default instantiation, convert the resource to an XML string, and then convert the XML string back into our internal List representation. 
Finally, we check if the newly deserialized resource is equal to it's default.

For each resource, the only part of this test that differs is the name of the type, making this test suite a very reasonable automation.
Not only will this inform of us any bugs or issues in YaSerde that lead to data loss, it will also inform us of any limitations of YaSerde, in terms of things it can and cannot serialize/deserialize.
Furthermore, as we make changes to our YaSerde fork, this test suite will inform us of any regressions.

However, this test suite is not capable of testing for resource serialization correctness; whether or not the outputted XML conforms to the specification. 

\subsubsection{Unit Tests}
The remainder of the common library will be tested using manually written unit tests.
A set of these unit tests will test whether resource serialization matches that of the specification using the provided example outputs, whilst others will ensure the network and security interfaces are correct.
These unit tests are paramount when working with our Rust crate dependencies, as they can be used to test for regressions if and when we choose to update them.

\section{Client Library}
Despite the claim that we are developing an IEEE 2030.5 client, in reality, the goal of this thesis is to produce a client library, such that manufacturers of IEEE 2030.5 complaint devices will extend upon our client.
These device manufacturers would simply, in Rust or otherwise, call upon the documented interface of the client library to communicate with a IEEE 2030.5 server.

The exact details of this client library interface are yet to be determined, but what a developer should be able to achieve with that interface is fairly straight forward. They'll require:

\begin{itemize}
    \item A mechanism for discovering or connecting to a specific server.
    \item The ability to retrieve resources from a specific URI, and have it deserialized into a local data type.
    \item The ability to create or update a resource, and have it included as a PUT or POST request to a connected server.
    \item A mechanism to automate this process, using event-driven architecture, to handle timer events, such as for polling, or network events for resource subscription.
\end{itemize}

\subsection{Server \& Connection}

Connecting to a server is, otherwise, as expected. We use the cipher suite interface and the TCP interface, as built in the common library, to connect to the server using TCP/TLS.
This of course requires certificates signed by a common library cipher suite. This certificate exchange will determine the parameters by which the cipher suite will be used to encrypt traffic.

\subsection{Event-driven Architecture}
With the IEEE 2030.5 Client being an I/O bound application, we are to implement concurrency using an event-driven architecture, such that many operations can performed concurrently on a single threaded machine when waiting on I/O.

Although the client does not connect to multiple servers, we require event-based architecture to handle:
\begin{itemize}
    \item Input from the client device, such as the creating or updating of resources.
    \item Timed events, such as to poll for a resource update on a given schedule.
    \item Network events, such as an updated resource being pushed to the client via the subscription/notification mechanism, or receiving the response from a sent HTTP request.
\end{itemize}

An event-based architecture furthermore enables us to take advantage of multiple OS threads, and therefore multiple CPU cores, as to best accommodate the scale required by the client aggregator model.
As mentioned previously, Rust supports asynchronous programming, with runtime-agnostic support for await and async syntax, of which there are multiple Rust async runtime available.

The specifics of this asynchronous programming architecture are yet to be learned, and as such we can look to the EPRI client implementation, where they've chosen to use the Linux native \texttt{epoll} \texttt{syscall}.
Fortunately, \texttt{epoll} is the driver behind the two most popular async runtimes for Rust, \texttt{Tokio} and \texttt{std-async}. As such, we'll need to determine which is most suitable for our client.

\subsection{Function Sets}
As established, function sets are logical groupings of IEEE 2030.5 resources by their functionality, of which there are twenty-five.
A subset of these function sets are for general or 'Common' use, such as the time function set, for synchronizing a device clock, whilst others have a very specific scope, such as the Electric Vehicle function set. 

QualityLogic, a quality assurance company specialising in testing standardised software, has grouped these function sets further than the specification itself.

Figure 5.8 shows these groupings, and which of these function sets are required for California SIP.
These groupings provide us with a starting point for determining the priority of function sets, where by those required for California SIP will be implemented first.
An exception to this is the Demand Response and Load Control function set, which has been deemed relevant for DER in Australia by electric utilities in Queensland, and as such it's implementation will be prioritised. \cite[]{QueenslandDER}

Regardless, the groupings in Figure 5.8 further indicate the dependencies between function sets. For example the Device Capabilities function set describes the function sets available on a server, and is therefore used to discover the URI of resources for other function sets.

The conclusion to draw from this is that function sets on the left side of Figure 5.8 are very much depended upon by function sets on the right side, as they describe the core functionality on the client.
Our development will begin on the Security, Certificate Management, and Application Support function sets as part of the common library, where the Application Support function set refers to the use of prescribed technologies, such as TCP, HTTP/1.1 and XML.


\subsection{Testing}
As expected, our client library will be developed alongside a suite of tests. Unlike the common library, these tests will be comprised of both unit and system tests.
System tests will primarily be used to check for conformance to the IEEE 2030.5 specification, using the example system outputs in the specification.
The actual software framework to be used for conducting system tests is yet to be determined, but the requirements to use such a framework are relatively straightforward, obviously requiring both a test client binary, and a mock server.


\subsubsection{Test Client Binary}
In order to perform system tests we will need to wrap our client library and produce a binary that will connect to a server, simulating a potential use case.
This binary client will be a demonstration of all implemented functionality.
Furthermore, this client binary will act as documentation for device manufacturers using our library.
Likewise, EPRI produced a test client binary for demonstration purposes in their IEEE 2030.5 client implementation.

\subsubsection{Mock Server}

When it comes to writing system tests, our testing philosophy is hindered by a lack of open-source IEEE 2030.5 implementations, in-development or otherwise.
As such, we'll need to create our own mock IEEE 2030.5 server to test both the sending and receiving of resources from our client.
Neel Bhaskar, as part of UNSW CSE, developed a portion of a working IEEE 2030.5 Server in 2022, and with changes to support hardcoded resources and routes, will be used as the starting point for this mock server.
We will also need to make changes to this server in order for it to use our common library, where we will therefore gain a better idea of what functionality is common to both client \& server.

Specific client functionality, such as the subscription/notification method of resource retrieval, may require extensive work on this mock server. 
As a result, we won't rule out the possibility of writing code that could be reused in a future server implementation.









